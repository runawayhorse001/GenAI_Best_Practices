

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8. Reinforcement Learning from Human Feedback (RLHF) &mdash; GenAI: Best Practices 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />

  
    <link rel="shortcut icon" href="_static/icon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=f2a433a1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. LLM Evaluation Metrics" href="evaluation.html" />
    <link rel="prev" title="7. Pre-training" href="pretraining.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            GenAI: Best Practices
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">1. Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="prelim.html">2. Preliminary</a></li>
<li class="toctree-l1"><a class="reference internal" href="embedding.html">3. Word and Sentence Embedding</a></li>
<li class="toctree-l1"><a class="reference internal" href="prompt.html">4. Prompt Engineering</a></li>
<li class="toctree-l1"><a class="reference internal" href="rag.html">5. Retrieval-Augmented Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="finetuning.html">6. Fine Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pretraining.html">7. Pre-training</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Reinforcement Learning from Human Feedback (RLHF)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ppo">8.1. PPO</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#state-action-and-reward-in-the-context-of-llms">8.1.1. <strong>State, Action, and Reward in the Context of LLMs</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ppo-objective-function">8.1.2. <strong>PPO Objective Function</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#steps-of-rlhf-using-ppo">8.1.3. <strong>Steps of RLHF Using PPO</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rlhf-training-tricks">8.1.4. RLHF Training Tricks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dpo">8.2. DPO</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dpo-objective">8.2.1. DPO Objective</a></li>
<li class="toctree-l3"><a class="reference internal" href="#steps-of-rlhf-using-dpo">8.2.2. Steps of RLHF Using DPO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dpo-variants">8.2.3. DPO Variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#main-difficulties-in-rlhf">8.3. Main Difficulties in RLHF</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-collection">8.3.1. <strong>Data Collection</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#reward-hacking">8.3.2. <strong>Reward Hacking</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="evaluation.html">9. LLM Evaluation Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="guardrails.html">10. LLM Guardrails</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">11. Main Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GenAI: Best Practices</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">8. </span>Reinforcement Learning from Human Feedback (RLHF)</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="reinforcement-learning-from-human-feedback-rlhf">
<span id="rlhf"></span><h1><span class="section-number">8. </span>Reinforcement Learning from Human Feedback (RLHF)<a class="headerlink" href="#reinforcement-learning-from-human-feedback-rlhf" title="Link to this heading"></a></h1>
<p>The process of training a model using reinforcement learning from human
feedback (RLHF) involves three key steps, as outlined in the paper
titled “<a class="reference external" href="https://arxiv.org/abs/2203.02155">Training language models to follow instructions with human
feedback</a>” by OpenAI <a class="reference internal" href="reference.html#longouyang" id="id1"><span>[LongOuyang]</span></a>.</p>
<figure class="align-center" id="id6">
<img alt="instructGPT_overview_RLHF" src="_images/instructGPT_overview_RLHF.png" />
<figcaption>
<p><span class="caption-text">InstructGPT Overview (Source: <a class="reference external" href="https://arxiv.org/abs/2203.02155">Training language models to follow instructions with human feedback</a>)</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="ppo">
<h2><span class="section-number">8.1. </span>PPO<a class="headerlink" href="#ppo" title="Link to this heading"></a></h2>
<p>Proximal Policy Optimization (PPO) (Paper: <a class="reference external" href="https://arxiv.org/abs/1707.06347">Proximal Policy Optimization
Algorithms</a>) is a key algorithm
used in RLHF to fine-tune language models based on human preferences. It
is utilized to optimize the policy of a language model by maximizing a
reward function derived from human feedback. This process helps align
the model’s outputs with human values and preferences. <a class="reference internal" href="reference.html#johnschulman" id="id2"><span>[JohnSchulman]</span></a></p>
<section id="state-action-and-reward-in-the-context-of-llms">
<h3><span class="section-number">8.1.1. </span><strong>State, Action, and Reward in the Context of LLMs</strong><a class="headerlink" href="#state-action-and-reward-in-the-context-of-llms" title="Link to this heading"></a></h3>
<p>In the context of LLMs, the components of reinforcement learning are
defined as follows:</p>
<ol class="arabic simple">
<li><p><strong>State</strong>: The state corresponds to the <strong>input prompt</strong> or context
provided to the language model. It represents the scenario or query
that requires a response.</p></li>
<li><p><strong>Action</strong>: The action is the <strong>output</strong> generated by the language
model, i.e., the response or continuation of text based on the given
state (prompt).</p></li>
<li><p><strong>Reward</strong>: The reward is a scalar value that quantifies how well the
generated response aligns with human preferences or task objectives.
It is typically derived from a <strong>reward model</strong> trained on human
feedback.</p></li>
<li><p><strong>Policy</strong>: A policy refers to the strategy or function that maps a
given state (input prompt and context) to an action (the next token
or sequence of tokens to generate). The policy governs how the LLM
generates responses and is optimized to maximize a reward signal,
such as alignment with human preferences or task-specific objectives.</p></li>
</ol>
<p><strong>Proximal Policy Optimization (PPO)</strong> is a reinforcement learning
algorithm designed to optimize the policy of an agent in a stable and
efficient manner. It is particularly effective in environments with
discrete or continuous action spaces. Here’s an overview of PPO along
with its objective function:</p>
</section>
<section id="ppo-objective-function">
<h3><span class="section-number">8.1.2. </span><strong>PPO Objective Function</strong><a class="headerlink" href="#ppo-objective-function" title="Link to this heading"></a></h3>
<p>PPO algorithm extends the CLIP objective by incorporating additional
terms for value function optimization and entropy regularization.</p>
<div class="math notranslate nohighlight">
\[J^{PPO}(\theta) = E[J^{CLIP}(\theta) - c_1(V_\theta(s)-V_{target})^2 + c_2 H(s,\pi_\theta(\cdot))]\]</div>
<p>where</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(J^{CLIP}(\theta)\)</span> is CLIP objective in policy gradient methods.
The use of the minimum function ensures that if the new policy’s
probability ratio deviates too much from 1 (indicating a significant
change), it will not receive excessive credit (or blame) for its
performance based on the advantage estimate.</p>
<div class="math notranslate nohighlight">
\[J^{CLIP}(\theta) = E[\min(r(\theta)\hat{A}_{\theta_{old}}(s,a)), \text{clip}(r(\theta),1-\epsilon, 1+\epsilon) \hat{A}_{\theta_{old}}(s,a)]\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(-(V_\theta(s) - V_{target})^2\)</span> is the negative mean squared
error (MSE), which we aim to maximize. It minimizes the difference
between the predicted value function <span class="math notranslate nohighlight">\(V_\theta(s)\)</span> and the
target value <span class="math notranslate nohighlight">\(V_{target}\)</span>. The coefficient <span class="math notranslate nohighlight">\(c_2\)</span> controls
the tradeoff between policy optimization and value function fitting.</p></li>
<li><p><span class="math notranslate nohighlight">\(H(s,\pi_\theta(\cdot))\)</span> represents the entropy of the policy.
Maximizing entropy encourages exploration by preventing premature
convergence to deterministic policies. The coefficient <span class="math notranslate nohighlight">\(c_2\)</span>
determines the weight of this entropy term.</p></li>
</ul>
<p>Below is a pseudocode of PPO-Clip Algorithm</p>
<figure class="align-center" id="id7">
<img alt="ppo_clip_algo" src="_images/ppo_clip_algo.png" />
<figcaption>
<p><span class="caption-text">PPO Clip Algorithm (Source: <a class="reference external" href="https://spinningup.openai.com/en/latest/algorithms/ppo.html">OpenAI Spinning Up - Proximal Policy Optimization</a>)</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="steps-of-rlhf-using-ppo">
<h3><span class="section-number">8.1.3. </span><strong>Steps of RLHF Using PPO</strong><a class="headerlink" href="#steps-of-rlhf-using-ppo" title="Link to this heading"></a></h3>
<p>The RLHF process using PPO involves three main stages:</p>
<ol class="arabic">
<li><p><strong>Training a Reward Model</strong>: A reward model is trained to predict
human preferences based on labeled data. Human annotators rank
multiple responses for each prompt, and this ranking data is used to
train the reward model in a supervised manner. The reward model
learns to assign higher scores to responses that align better with
human preferences.</p></li>
<li><p><strong>Fine-Tuning the LLM with PPO</strong>: After training the reward model,
PPO is used to fine-tune the LLM. The steps are as follows:</p>
<ol class="arabic">
<li><p><strong>Initialize Policies</strong>: Start with a pre-trained LLM as both the
<strong>policy model</strong> (actor) and optionally as the critic for value
estimation.</p>
<ul>
<li><p>The <strong>actor</strong> is the language model that generates responses
(actions) based on input prompts (states).</p>
<p>For example: Input: “Explain quantum mechanics.” Output:
“Quantum mechanics is a branch of physics that studies particles
at atomic and subatomic scales.”</p>
</li>
<li><p>The <strong>critic</strong> is typically implemented as a <strong>value function</strong>,
which predicts how good a particular response (action) is in
terms of achieving long-term objectives. This model predicts a
scalar value for each token or sequence, representing its
expected reward or usefulness.</p>
<p>For example:</p>
<p>Input: “Explain quantum mechanics.” → “Quantum mechanics is…”
Output: A value score indicating how well this response aligns
with human preferences or task objectives.</p>
</li>
<li><p>Both the actor and critic can be initialized from the same
pre-trained LLM weights to leverage shared knowledge from
pretraining. However, their roles diverge during fine-tuning:
The actor focuses on generating responses. The critic focuses on
evaluating those responses.</p></li>
</ul>
</li>
<li><p><strong>Collect Rollouts</strong>: Interact with the environment by sampling
prompts from a dataset. Generate responses (actions) using the
current policy. Compute rewards for these responses using the
trained reward model.</p></li>
<li><p><strong>Compute Advantage Estimates</strong>: Use rewards from the reward model
and value estimates from the critic to compute advantages:</p>
<div class="math notranslate nohighlight">
\[\hat{A}(s, a) = R_t + \gamma V(s_{t+1}) - V(s_t),\]</div>
<p>where $ R_t $ is the reward from the reward model.</p>
</li>
<li><p><strong>Optimize Policy with PPO Objective</strong>: Optimize the policy using
PPO’s clipped surrogate objective:</p>
<div class="math notranslate nohighlight">
\[J^{CLIP}(\theta) = \mathbb{E}\left[\min\left(r(\theta)\hat{A}(s, a), \text{clip}(r(\theta), 1-\epsilon, 1+\epsilon)\hat{A}(s, a)\right)\right],\]</div>
<p>where $ r(theta) = frac{pi_theta(a|s)}{pi_{theta_{text{old}}}(a|s)}
$ is the probability ratio between new and old policies.</p>
</li>
<li><p><strong>Update Value Function</strong>: Simultaneously update the value
function by minimizing mean squared error between predicted values
and rewards:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}_{\text{value}} = \mathbb{E}\left[(V_\theta(s) - R_t)^2\right].\]</div>
</li>
<li><p><strong>Repeat</strong>: Iterate over multiple epochs until convergence,
ensuring stable updates by clipping policy changes.</p></li>
</ol>
</li>
<li><p><strong>Evaluation</strong>: Evaluate the fine-tuned LLM on unseen prompts to
ensure it generates outputs aligned with human preferences.
Optionally, collect additional human feedback to further refine both
the reward model and policy.</p></li>
</ol>
<p>The following diagrams summarizes the high-level RLHF process with PPO,
from preference data creation, to training a reward model, and using
reward model in an RL loop to fine tune LLM.</p>
<figure class="align-center" id="id8">
<img alt="PPO_RLHF_flowchart" src="_images/PPO_RLHF_flowchart.png" />
<figcaption>
<p><span class="caption-text">Flowchart of PPO in RLHF</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The following workflow chart illustrates the more detailed training
process of RLHF with PPO. <a class="reference internal" href="reference.html#ruizheng" id="id3"><span>[RuiZheng]</span></a></p>
<figure class="align-center" id="id9">
<img alt="RLHF_training_realworld" src="_images/RLHF_training_realworld.png" />
<figcaption>
<p><span class="caption-text">RLHF Training Workflow (Source: <a class="reference external" href="https://arxiv.org/abs/2307.04964">Secrets of RLHF in Large Language Models Part I PPO</a>)</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rlhf-training-tricks">
<h3><span class="section-number">8.1.4. </span>RLHF Training Tricks<a class="headerlink" href="#rlhf-training-tricks" title="Link to this heading"></a></h3>
<p>There are practical challenges that arise during RLHF training. These
challenges stem from the inherent complexities of RL, especially when
applied to aligning LLMs with human preferences. Therefore, tricks are
essential for addressing the practical limitations of RLHF, ensuring the
training process remains efficient, stable, and aligned with human
preferences while minimizing the impact of inherent challenges in RL
systems.</p>
<figure class="align-center" id="id10">
<img alt="RLHF_training_tricks" src="_images/RLHF_training_tricks.png" />
<figcaption>
<p><span class="caption-text">RLHF Training Tricks (Source: <a class="reference external" href="https://arxiv.org/abs/2307.04964">Secrets of RLHF in Large Language Models Part I
PPO</a>)</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="dpo">
<h2><span class="section-number">8.2. </span>DPO<a class="headerlink" href="#dpo" title="Link to this heading"></a></h2>
<p>The main reason why RLHF with PPO is hard is that it takes a lot of
redundant effort. Policy Model is all we need, all other efforts are not
necessary. <strong>DPO (Direct Preference Optimization)</strong> is a novel
alternative to traditional RLHF for fine-tuning LLMs. It simplifies the
RLHF process by eliminating the need for complex reward models and RL
algorithms. Instead, DPO reframes the problem of aligning LLMs with
human preferences as a classification problem using human-labeled
preference data. <a class="reference internal" href="reference.html#rafaelrafailov" id="id4"><span>[RafaelRafailov]</span></a></p>
<p>The main idea is DPO and difference between DPO and PPO are shown in the
figure below</p>
<figure class="align-center" id="id11">
<img alt="DPO_idea" src="_images/DPO_idea.png" />
<figcaption>
<p><span class="caption-text">DPO Idea in the Paper (Source: <a class="reference external" href="https://arxiv.org/abs/2305.18290">Direct Preference Optimization Your Language Model is Secretly a Reward Model</a>)</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="dpo-objective">
<h3><span class="section-number">8.2.1. </span>DPO Objective<a class="headerlink" href="#dpo-objective" title="Link to this heading"></a></h3>
<p><strong>RLHF objective</strong> is defined as follows. Keep in mind that no matter
whether DPO or PPO is used, the objective is always like this.</p>
<div class="math notranslate nohighlight">
\[\max_{\pi_\theta} E_{x \sim D, y \sim \pi_\theta(y|x)}\Big[r_{\phi}(x,y) - \beta D_{KL}\big[\pi_\theta(y|x) || \pi_{ref}(y|x)\big]\Big]\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta D_{KL}\big[\pi_\theta(y|x) || \pi_{ref}(y|x)\big]\)</span> is
a regularization term. When applying RL to NLP, regularization is often
needed. Otherwise RL would explore every possible situation and find out
hidden tricks which deviate from a language model.</p>
<p><strong>DPO’s objective function</strong> is derived by incoroprating the probability
of preference from reward function of optimal policy. DPO paper has
provided detailed steps of deriving the gradient of the DPO objective:<a class="reference internal" href="reference.html#rafaelrafailov" id="id5"><span>[RafaelRafailov]</span></a></p>
<div class="math notranslate nohighlight">
\[L_{DPO}(\pi_\theta; \pi_{ref}) = -E_{(x,y_w,y_l) \sim D} \Big[\log \sigma \Big(\beta \log {\pi_{\theta}(y_w|x)\over \pi_{ref}(y_w|x)} - \beta \log {\pi_{\theta}(y_l|x)\over \pi_{ref}(y_l|x)}\Big)\Big)\Big]\]</div>
<p><strong>Key ideas of DPO objective</strong>:</p>
<ul class="simple">
<li><p>DPO’s objective aims to increase the likelihood of generating
preferred responses over less preferred ones. By focusing directly on
preference data, DPO eliminates the need to first fit a reward model
that predicts scalar rewards based on human preferences. This
simplifies the training pipeline and reduces computational overhead.</p></li>
<li><p>Value functions exist to help reduce the variance of the reward model.
In DPO, the value function is not involved because DPO does not rely
on a traditional RL framework, such as Actor-Critic methods. Instead,
DPO directly optimizes the policy using human preference data as a
<strong>classification task</strong>, skipping the intermediate steps of training a
reward model or estimating value functions.</p></li>
<li><p>DPO was originally designed to work with <strong>pairwise</strong> preference data,
however, recent advancements and adaptations have extended its
applicability to ranking preference data as well (e.g RankDPO).</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="k">def</span> <span class="nf">dpo_loss</span><span class="p">(</span><span class="n">pi_logps</span><span class="p">,</span> <span class="n">ref_logps</span><span class="p">,</span> <span class="n">yw_idxs</span><span class="p">,</span> <span class="n">yl_idxs</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pi_logps: policy logprobs, shape (B,)</span>
<span class="sd">    ref_logps: reference model logprobs, shape (B,)</span>
<span class="sd">    yw_idxs: preferred completion indices in [0, B-1], shape (T,)</span>
<span class="sd">    yl_idxs: dispreferred completion indices in [0, B-1], shape (T,)</span>
<span class="sd">    beta: temperature controlling strength of KL penalty</span>

<span class="sd">    Each pair of (yw_idxs[i], yl_idxs[i]) represents the</span>
<span class="sd">    indices of a single preference pair.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pi_yw_logps</span><span class="p">,</span> <span class="n">pi_yl_logps</span> <span class="o">=</span> <span class="n">pi_logps</span><span class="p">[</span><span class="n">yw_idxs</span><span class="p">],</span> <span class="n">pi_logps</span><span class="p">[</span><span class="n">yl_idxs</span><span class="p">]</span>
    <span class="n">ref_yw_logps</span><span class="p">,</span> <span class="n">ref_yl_logps</span> <span class="o">=</span> <span class="n">ref_logps</span><span class="p">[</span><span class="n">yw_idxs</span><span class="p">],</span> <span class="n">ref_logps</span><span class="p">[</span><span class="n">yl_idxs</span><span class="p">]</span>

    <span class="n">pi_logratios</span> <span class="o">=</span> <span class="n">pi_yw_logps</span> <span class="o">-</span> <span class="n">pi_yl_logps</span>
    <span class="n">ref_logratios</span> <span class="o">=</span> <span class="n">ref_yw_logps</span> <span class="o">-</span> <span class="n">ref_yl_logps</span>

    <span class="n">losses</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">logsigmoid</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">pi_logratios</span> <span class="o">-</span> <span class="n">ref_logratios</span><span class="p">))</span>
    <span class="n">rewards</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">pi_logps</span> <span class="o">-</span> <span class="n">ref_logps</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">losses</span><span class="p">,</span> <span class="n">rewards</span>
</pre></div>
</div>
</section>
<section id="steps-of-rlhf-using-dpo">
<h3><span class="section-number">8.2.2. </span>Steps of RLHF Using DPO<a class="headerlink" href="#steps-of-rlhf-using-dpo" title="Link to this heading"></a></h3>
<p><strong>1. Initial Setup and Supervised Fine-Tuning (SFT)</strong>: Begin by
fine-tuning a pre-trained LLM using supervised learning on a dataset
that is representative of the tasks the model will perform. This step
ensures the model has a strong foundation in the relevant domain,
preparing it for preference-based optimization.</p>
<p><strong>2. Collect Preference Data</strong>: Gather human feedback in the form of
pairwise preferences or rankings. Annotators evaluate responses
generated by the model and indicate which ones they prefer. Construct a
dataset of prompts and corresponding preferred and less-preferred
responses.</p>
<p><strong>3. Iterative Rounds of DPO</strong></p>
<ul class="simple">
<li><p><strong>Sampling and Annotation</strong>: In each round, sample a set of responses
from the model for given prompts. Collect new preference annotations
based on these samples, allowing for dynamic updates to the preference
dataset. (Public preference data works as well. Off-policy and
on-policy data both work).</p></li>
<li><p><strong>Preference Optimization</strong>: Use DPO to adjust the model’s outputs
based on collected preference data:</p></li>
<li><p><strong>Model Update</strong>: Fine-tune the model using this loss function to
increase the likelihood of generating preferred responses.</p></li>
</ul>
<p><strong>4. Evaluation and Iteration</strong></p>
<ul class="simple">
<li><p><strong>Performance Assessment</strong>: After each round, evaluate the model’s
performance on new prompts to ensure it aligns with human preferences.
Use feedback from these evaluations to inform subsequent rounds of
sampling and optimization.</p></li>
<li><p><strong>Iterative Refinement</strong>: Continue this loop process over multiple
rounds, iteratively refining the model’s alignment with human
preferences through continuous sampling and preference optimization.</p></li>
</ul>
</section>
<section id="dpo-variants">
<h3><span class="section-number">8.2.3. </span>DPO Variants<a class="headerlink" href="#dpo-variants" title="Link to this heading"></a></h3>
<p>The key area of research involves developing variants of DPO and
conducting theoretical analyses to understand its limitations and
potential improvements. This includes exploring different loss functions
or optimization strategies that can be applied within the DPO framework.</p>
<ul>
<li><p>One significant area of research focuses on refining the loss function
used in DPO. This includes exploring ways to eliminate the need for a
reference model, which can simplify the optimization process.</p>
<p>Examples:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/2403.07691">ORPO: Monolithic Preference Optimization without Reference
Model</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/2405.14734">SimPO: Simple Preference Optimization with a Reference-Free
Reward</a></p></li>
</ul>
</li>
<li><p>Another key direction involves leveraging existing supervised
fine-tuning data as preference data for DPO. This strategy aims to
enhance the quality of preference data by utilizing high-quality
labeled datasets that may already exist from previous SFT processes.</p>
<p>Examples:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/2402.08005v1">Refined Direct Preference Optimization with Synthetic Data for
Behavioral Alignment of LLMs</a></p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="main-difficulties-in-rlhf">
<h2><span class="section-number">8.3. </span>Main Difficulties in RLHF<a class="headerlink" href="#main-difficulties-in-rlhf" title="Link to this heading"></a></h2>
<section id="data-collection">
<h3><span class="section-number">8.3.1. </span><strong>Data Collection</strong><a class="headerlink" href="#data-collection" title="Link to this heading"></a></h3>
<p>In practice, people noticed that the collection of human feedback in the
form of the preference dataset is a slow manual process that needs to be
repeated whenever alignment criteria change. And there is increasing
difficulty in annotating preference data as models become more advanced,
particularly because distinguishing between outputs becomes more nuanced
and subjective.</p>
<ul class="simple">
<li><p>The paper “<a class="reference external" href="https://arxiv.org/abs/2411.02481">CDR: Customizable Density Ratios of Strong-over-weak LLMs
for Preference Annotation</a>”
explains that as models become more advanced, it becomes harder to
identify which output is better due to subtle differences in quality.
This makes preference data annotation increasingly difficult and
subjective.</p></li>
<li><p>Another paper, “<a class="reference external" href="https://arxiv.org/abs/2407.14916">Improving Context-Aware Preference Modeling for
Language Models</a>,” discusses how
the underspecified nature of natural language and multidimensional
criteria make direct preference feedback difficult to interpret. This
highlights the challenge of providing consistent annotations when
outputs are highly sophisticated and nuanced.</p></li>
<li><p>“<a class="reference external" href="https://www.arxiv.org/abs/2408.12799">Less for More: Enhancing Preference Learning in Generative Language
Models</a>” also notes that
ambiguity among annotators leads to inconsistently annotated datasets,
which becomes a greater issue as model outputs grow more complex.</p></li>
</ul>
</section>
<section id="reward-hacking">
<h3><span class="section-number">8.3.2. </span><strong>Reward Hacking</strong><a class="headerlink" href="#reward-hacking" title="Link to this heading"></a></h3>
<p>Reward hacking is a common problem in reinforcement learning, where the
agent learns to exploit the system by maximizing its reward through
actions that deviate from the intended goal. In the context of RLHF,
reward hacking occurs when training settles in an unintended region of
the loss landscape. In this scenario, the model generates responses that
achieve high reward scores, but these responses may fail to be
meaningful or useful to the user.</p>
<p>In PPO, reward hacking occurs when the model exploits flaws or
ambiguities in the <strong>reward model</strong> to achieve high rewards without
genuinely aligning with human intentions. This is because PPO relies on
a learned reward model to guide policy updates, and any inaccuracies or
biases in this model can lead to unintended behaviors being rewarded.
PPO is particularly vulnerable to reward hacking if the reward model is
not robustly designed or if it fails to capture the true objectives of
human feedback. The iterative nature of PPO, which involves continuous
policy updates based on reward signals, can exacerbate this issue if not
carefully managed.</p>
<p>DPO avoids explicit reward modeling by directly optimizing policy based
on preference data. However, it can still encounter issues similar to
reward hacking if the preference data is <strong>biased</strong> or if the
optimization process leads to <strong>overfitting</strong> specific patterns in the
data that do not generalize well. While DPO does not suffer from reward
hacking in the traditional sense (since it lacks a separate reward
model), it can still find biased solutions that exploit
<strong>out-of-distribution responses</strong> or deviate from intended behavior due
to distribution shifts between training and deployment contexts.</p>
<ul class="simple">
<li><p>The article “<a class="reference external" href="https://lilianweng.github.io/posts/2024-11-28-reward-hacking/">Reward Hacking in Reinforcement
Learning</a>”
by Lilian Weng discusses how reward hacking occurs when a RL agent
exploits flaws or ambiguities in the reward function to achieve high
rewards without genuinely learning the intended task. It highlights
that in RLHF for language models, reward hacking is a critical
challenge, as models might learn to exploit unit tests or mimic biases
to achieve high rewards, which can hinder real-world deployment.</p></li>
<li><p>The research “<a class="reference external" href="https://arxiv.org/abs/2210.10760">Scaling Laws for Reward Model
Overoptimization</a>” explores how
optimizing against reward models trained to predict human preferences
can lead to overoptimization, hindering the actual objective.</p>
<ol class="arabic simple">
<li><p><strong>Impact of Policy Model Size</strong>: Holding the RM size constant,
experiments showed that larger policy models exhibited similar
overoptimization trends as smaller models, despite achieving higher
initial gold scores. This implies that their higher performance on
gold rewards does not lead to excessive optimization pressure on
the RM.</p></li>
<li><p><strong>Relationship with RM Data Size</strong>: Data size had a notable effect
on RM performance and overoptimization. Models trained on fewer
than ~2,000 comparison labels showed near-chance performance, with
limited improvement in gold scores. Beyond this threshold, all RMs,
regardless of size, benefited from increased data, with larger RMs
showing greater improvements in gold rewards compared to smaller
ones.</p></li>
<li><p><strong>Scaling Laws for RM Parameters and Data Size</strong>: Overoptimization
patterns scaled smoothly with both RM parameter count and data
size. Larger RMs demonstrated better alignment with gold rewards
and less susceptibility to overoptimization when trained on
sufficient data, indicating improved robustness.</p></li>
<li><p><strong>Proxy vs. Gold Reward Trends</strong>: For small data sizes, proxy
reward scores deviated significantly from gold reward scores,
highlighting overoptimization risks. As data size increased, the
gap between proxy and gold rewards narrowed, reducing
overoptimization effects.</p></li>
</ol>
</li>
</ul>
<p>Note that the KL divergence term in the RLHF objective is intended to
prevent the policy from deviating too much from a reference model,
thereby maintaining stability during training. However, it does not
fully prevent reward hacking. Reward hacking occurs when an agent
exploits flaws or ambiguities in the reward model to achieve high
rewards without genuinely aligning with human intentions. The KL
divergence penalty does not correct these flaws in the reward model
itself, meaning that if the reward model is misaligned, the agent can
still find ways to exploit it. KL does not directly address whether the
actions align with the true objectives or desired outcomes.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pretraining.html" class="btn btn-neutral float-left" title="7. Pre-training" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="evaluation.html" class="btn btn-neutral float-right" title="9. LLM Evaluation Metrics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Wenqiang Feng, Di Zhen and Wenyun Wang.
      <span class="lastupdated">Last updated on Dec 30, 2024.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>